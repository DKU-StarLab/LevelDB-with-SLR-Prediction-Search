// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file. See the AUTHORS file for names of contributors.
//
// Decodes the blocks generated by block_builder.cc.

#include "table/block.h"

#include <algorithm>
#include <cstdint>
#include <vector>

#include <fstream>
#include <sstream>
#include <string>


#include "leveldb/comparator.h"
#include "table/format.h"
#include "util/coding.h"
#include "util/logging.h"
#include <typeinfo>

#include<iostream>
using namespace std;

namespace leveldb {

inline uint32_t Block::NumRestarts() const {
  assert(size_ >= sizeof(uint32_t));
  
  /*
  cout << "data_ : " << data_ << endl;
  cout << "sizeof(uint32_t) : " << sizeof(uint32_t) << endl;
  cout << "size : " << size_ << endl;
  cout << "sblm decode : " << data_ + size_ - sizeof(uint32_t) << endl;
  
  if(size_ == 4121 && sizeof(uint32_t) == 4){
	  cout << "aku 1900 " << endl;
  }
  
  printf("Car %c \n", data_ + size_ - sizeof(uint32_t));
  
  //char a = 'B';
	//const char *b = new char(a);
	
	// std::string s;
	  // for (uint32_t v = 0; v < 50; v++) {
		// PutFixed32(&s, v);
	  // }
	  
	  // cout << "ber " << s << endl;

	  // const char* p = s.data();
	  // for (uint32_t v = 0; v < 50; v++) {
		// uint32_t actual = DecodeFixed32(p);
		// // ASSERT_EQ(v, actual);
		// cout << " v " << v << " act " << actual << " p " << p << endl; 
		// p += sizeof(uint32_t);
	  // }
	 // printf(sizeof(uint32_t));
	// uint32_t a = data_ + 1900; 
	const char *b = data_ + size_ - sizeof(uint32_t);
	
	
	const char *s = b;
	std::string str(s);
	// int a = atoi(data_);
	cout << "a : " << s << endl;
	
	// const char *b =data_ + 1900; 
	// unsigned int vIn = 1900;
	// char b [11];
	// _ultoa_s(vIn,b,sizeof(b),10);
	
	if(size_ == 1908 && sizeof(uint32_t) == 4){
		const char *cstr = data_ + size_ - 4;
		cout << "babukaw" << DecodeFixed32(cstr) << endl;
		// size_ =size_ - sizeof(uint32_t)
	}
	
	if(size_ == 1909 && sizeof(uint32_t) == 4){
		string strx = "B" ;
		// const char *cstr = &strx[0]; 
		const char *cstr = data_ + 4121 - 4;
		// const char *cstr2 = 4121 - 4;
		const char *cstr2 = "NAK"; 
		
		int d = atol(cstr);
		printf("tol %d\n", d);
		
		printf("val %d \n", d);
		printf("Carx %c \n", cstr);
		printf("Carxx %c \n", data_);
		printf("Carxxx %c \n", cstr2);
		// uint32_t cstr = data_ + 1900; 
		// std::ifstream file(cstr, std::ios_base::binary);
		std::ifstream file(data_, std::ios_base::binary);
		std::ostringstream buffer;
		buffer << file.rdbuf();
		// return buffer.str();
		
		cout << "buffer : " << buffer.str() << endl;
		cout << "cstr : " << cstr << endl;
		printf("cstrhex %02hhx \n", data_);
		cout << "cstrx : " << b << endl;
		
		// const char *b ='1900'; 
		
		cout << "sizeb : " << b << endl;
		cout << "babuk" << DecodeFixed32(cstr) << endl;
	}
	printf("cstrhex %02hhx \n", data_);
	printf("cstrhex %02hhx \n", size_);
	printf("cstrhex %02hhx \n", sizeof(uint32_t));
	printf("cstrhex %02hhx \n", data_ + size_ - sizeof(uint32_t));
	cout << "sss : " << data_ + size_ - sizeof(uint32_t) << endl;
	// if(size_ == 1903){
		// return DecodeFixed32(data_ + size_ - sizeof(uint32_t) - sizeof(uint32_t));
	// }
	*/
	
  // return DecodeFixed32(data_ + size_ - sizeof(uint32_t));
  return DecodeFixed32(data_ + size_ - sizeof(uint32_t));
}

//function to help determine the meta location
inline uint32_t Block::MetaPosition(int type,int pos) const {
	int ret = new_meta_size + 1 - type - (3 * (pos-1));
	
	// cout << "Metapos " << type << " => " << pos <<" => " << ret << endl;
	// return pos * sizeof(uint32_t);
	return ret * sizeof(uint32_t);
}


 //fill constant of LR dividend
inline uint32_t Block::Dividend(int pos) const {
  assert(size_ >= sizeof(uint32_t));
  // return DecodeFixed32(data_ + size_ - sizeof(uint32_t) - sizeof(uint32_t));
  return DecodeFixed32(data_ + size_ - MetaPosition(1,pos));
}

 //fill LR Divisor 
inline uint32_t Block::Divisor(int pos) const {
  assert(size_ >= sizeof(uint32_t));
  // return DecodeFixed32(data_ + size_ - sizeof(uint32_t) - sizeof(uint32_t) - sizeof(uint32_t));
  // return DecodeFixed32(data_ + size_ - MetaPosition(new_meta_size -pos));
  return DecodeFixed32(data_ + size_ - MetaPosition(2,pos));
  // return GetLengthPrefixedSlice(data_ + size_ - sizeof(uint32_t) - sizeof(uint32_t) - sizeof(uint32_t));
}

 //fill LR lowest subset
inline uint32_t Block::Lowest(int pos) const {
  assert(size_ >= sizeof(uint32_t));
  // return DecodeFixed32(data_ + size_ - sizeof(uint32_t) - sizeof(uint32_t) - sizeof(uint32_t));
  // return DecodeFixed32(data_ + size_ - MetaPosition(new_meta_size + 1 -pos));
  return DecodeFixed32(data_ + size_ - MetaPosition(3,pos));
  // return GetLengthPrefixedSlice(data_ + size_ - sizeof(uint32_t) - sizeof(uint32_t) - sizeof(uint32_t));
}


//function to help determine the meta location
static inline const uint32_t MetaPos(int type,int pos) {
	int ret = 33 - type - (3 * (pos-1));
	return ret * sizeof(uint32_t);
}

//function to call the dividend value
static inline const uint32_t DividendMeta(const char* data_, size_t size_, int pos) {
  assert(size_ >= sizeof(uint32_t));
  return DecodeFixed32(data_ + size_ - MetaPos(1,pos));
}

//function to call the divisor value
static inline const uint32_t DivisorMeta(const char* data_, size_t size_, int pos) {
  assert(size_ >= sizeof(uint32_t));
  return DecodeFixed32(data_ + size_ - MetaPos(2,pos));
}

//function to call the lowest value
static inline const uint32_t LowestMeta(const char* data_, size_t size_, int pos) {
  assert(size_ >= sizeof(uint32_t));
  return DecodeFixed32(data_ + size_ - MetaPos(3,pos));
}

//function to call the segment size value
static inline const uint32_t SegmentSize(const char* data_, size_t size_, int pos) {
  assert(size_ >= sizeof(uint32_t));
  return DecodeFixed32(data_ + size_ - (2 * sizeof(uint32_t)));
}



Block::Block(const BlockContents& contents)
    : data_(contents.data.data()),
      size_(contents.data.size()),
      owned_(contents.heap_allocated) {
		  
		  // cout << "Block::Block sizeb : " << size_ << endl;
		  // cout << "contents.data.size() : " << contents.data.size() << endl;
  if (size_ < sizeof(uint32_t)) {
    size_ = 0;  // Error marker
  } else {
    size_t max_restarts_allowed = (size_ - sizeof(uint32_t)) / sizeof(uint32_t);
    if (NumRestarts() > max_restarts_allowed) {
      // The size is too small for NumRestarts()
      size_ = 0;
    } else {
      // restart_offset_ = size_ - (1 + NumRestarts()) * sizeof(uint32_t);
	  
	  //size of new metas
      restart_offset_ = size_ - (new_meta_size + NumRestarts()) * sizeof(uint32_t);
	  
	  // cout << "rsize " << size_ << endl;
	  // cout << "(1 + NumRestarts()) " << 1 + NumRestarts() << endl;
	  // cout << "sizeof(uint32_t) " << sizeof(uint32_t) << endl;
	  // cout << "restart_offset_ " << restart_offset_ << endl;
	  // cout << "wow " << (1 + NumRestarts()) * sizeof(uint32_t) << endl;
    }
  }
}

Block::~Block() {
  if (owned_) {
    delete[] data_;
  }
}

// Helper routine: decode the next block entry starting at "p",
// storing the number of shared key bytes, non_shared key bytes,
// and the length of the value in "*shared", "*non_shared", and
// "*value_length", respectively.  Will not dereference past "limit".
//
// If any errors are detected, returns nullptr.  Otherwise, returns a
// pointer to the key delta (just past the three decoded values).
static inline const char* DecodeEntry(const char* p, const char* limit,
                                      uint32_t* shared, uint32_t* non_shared,
                                      uint32_t* value_length) {
  if (limit - p < 3) return nullptr;
  *shared = reinterpret_cast<const uint8_t*>(p)[0];
  *non_shared = reinterpret_cast<const uint8_t*>(p)[1];
  *value_length = reinterpret_cast<const uint8_t*>(p)[2];
  if ((*shared | *non_shared | *value_length) < 128) {
    // Fast path: all three values are encoded in one byte each
    p += 3;
  } else {
    if ((p = GetVarint32Ptr(p, limit, shared)) == nullptr) return nullptr;
    if ((p = GetVarint32Ptr(p, limit, non_shared)) == nullptr) return nullptr;
    if ((p = GetVarint32Ptr(p, limit, value_length)) == nullptr) return nullptr;
  }

  if (static_cast<uint32_t>(limit - p) < (*non_shared + *value_length)) {
    return nullptr;
  }
  return p;
}

class Block::Iter : public Iterator {
 private:
  const Comparator* const comparator_;
  const char* const data_;       // underlying block contents
  uint32_t const restarts_;      // Offset of restart array (list of fixed32)
  uint32_t const num_restarts_;  // Number of uint32_t entries in restart array

  // current_ is offset in data_ of current entry.  >= restarts_ if !Valid
  uint32_t current_;
  uint32_t restart_index_;  // Index of restart block in which current_ falls
  uint32_t dividend_;  // LR Dividend Variable
  uint32_t lowest_;  // LR Lowest Subset Variable
  uint32_t size_;  // LR Lowest Subset Variable
  std::string key_;
  Slice value_;
  Status status_;
  bool slr_;
  bool debug_;
  
  

  inline int Compare(const Slice& a, const Slice& b) const {
    return comparator_->Compare(a, b);
  }
  
  inline int CompareInt(const Slice& a, const Slice& b) const {
	std::string a_string= a.ToString();
	int a_int= stoi(a_string);
	
	string b_string= b.ToString();
	int b_int= stoi(b_string);
	
	cout << "mkki " << a_int << endl;
	cout << "tkki " << b_int << endl;
	cout << "a_int - b_int " << a_int - b_int << endl;
	
	if(a_int == b_int){
		return 0;
	}else {
		return a_int - b_int;
	}
	
  }

  // Return the offset in data_ just past the end of the current entry.
  inline uint32_t NextEntryOffset() const {
    return (value_.data() + value_.size()) - data_;
  }

  uint32_t GetRestartPoint(uint32_t index) {
    assert(index < num_restarts_);
	
	// cout << "GetRestartPoint data_ " << data_ << endl;
	// cout << "GetRestartPoint restarts_ " << restarts_ << endl;
	// cout << "GetRestartPoint index " << index  << endl;
	// cout << "GetRestartPoint index * sizeof(uint32_t) " << index * sizeof(uint32_t)  << endl;
	// cout << "GetRestartPoint restarts_1 " << restarts_ + index * sizeof(uint32_t)<< endl;
	// cout << "GetRestartPoint restarts_2 " << data_ + restarts_ + index * sizeof(uint32_t) << endl;
	
	// printf("Apa %02x \n", data_ + restarts_ + index * sizeof(uint32_t));
	// printf("wow cari restartpoint ");
	
	const char *cursor = data_ + restarts_ + index * sizeof(uint32_t) ; 
	  // printf("string: %s\nhex: ", string);
	// const char* cp = data_;
	// for ( ; *cp != '\0'; ++cp )
	// {
	   // printf("%02x", *cp);
	// }
	  // printf("\n");
	
    // return DecodeFixed32(cursor);
    return DecodeFixed32(data_ + restarts_ + index * sizeof(uint32_t));
  }

  void SeekToRestartPoint(uint32_t index) {
    key_.clear();
	
    restart_index_ = index;
	
	// cout << "restart_index_1 :" << restart_index_ << endl;
    // current_ will be fixed by ParseNextKey();

    // ParseNextKey() starts at the end of value_, so set value_ accordingly
    uint32_t offset = GetRestartPoint(index);
    value_ = Slice(data_ + offset, 0);
  }

 public:
  // Iter(const Comparator* comparator, const char* data, uint32_t restarts,uint32_t num_restarts)
  // Iter(const Comparator* comparator, const char* data, uint32_t restarts,uint32_t num_restarts, uint32_t dividend, float lowest, size_t size)
  Iter(const Comparator* comparator, const char* data, uint32_t restarts,uint32_t num_restarts,  size_t size, bool SLR, bool debug)
  // Iter(const Comparator* comparator, const char* data, uint32_t restarts,uint32_t num_restarts,  size_t size, bool SLR, bool debug)
      : comparator_(comparator),
        data_(data),
        restarts_(restarts),
        num_restarts_(num_restarts),
        current_(restarts_),
        restart_index_(num_restarts_),
		// dividend_(dividend),
		// lowest_(lowest),
		size_(size){
    assert(num_restarts_ > 0);
	
	// if(debug){
		// cout << "num_restarts_xxxx :" << num_restarts_ << endl;
		// // cout << "dividend_ :" << dividend_ << endl;
		// // cout << "lowest_ :" << lowest_ << endl;
		// cout << "ukuranku :" << size_ << endl;
		// cout << "SLR" << SLR << endl;
		// cout << "debug" << debug << endl;
	// }
	
	slr_=SLR;
	debug_=debug;
	
  }

  bool Valid() const override { return current_ < restarts_; }
  Status status() const override { return status_; }
  Slice key() const override {
    assert(Valid());
    return key_;
  }
  Slice value() const override {
    assert(Valid());
    return value_;
  }

  void Next() override {
    assert(Valid());
    ParseNextKey();
  }

  void Prev() override {
    assert(Valid());

    // Scan backwards to a restart point before current_
    const uint32_t original = current_;
    while (GetRestartPoint(restart_index_) >= original) {
      if (restart_index_ == 0) {
        // No more entries
        current_ = restarts_;
        restart_index_ = num_restarts_;
        return;
      }
      restart_index_--;
    }
	
	
	// cout << "restart_index_2 :" << restart_index_ << endl;

    SeekToRestartPoint(restart_index_);
    do {
      // Loop until end of current entry hits the start of original entry
    } while (ParseNextKey() && NextEntryOffset() < original);
  }

	// Binary search and Segmented Linear Regression search
	// Get the pre-determined coefficient and use it to predict the position
	// Use and call the correct segment data only.
  void Seek(const Slice& target) override {
    // Binary search in restart array to find the last restart point
    // with a key < target
	
	std::string togot= target.ToString();
    uint32_t left = 0;
    uint32_t right = num_restarts_ - 1;
    int current_key_compare = 0;
	
	// if(debug_){
		// cout << "Restart Index: " << restart_index_ << endl;
		// cout << "dividend seek: " << dividend_ << endl;
		// cout << "lowest_ seek: " << lowest_ << endl;
	// }
	
	// if SLR is active 
	// and the data is quite big
	if(restart_index_ > 50 && slr_ ){
		uint32_t find =  stoi(togot);
		uint32_t iteration;
		uint32_t lowestMeta=LowestMeta(data_,size_,1);
		int which_segment = 1;
		
		int segment_len = 10;
		for(int seg=1; seg <= segment_len; seg ++){
			iteration=LowestMeta(data_,size_,seg);
			if(find >= iteration){
				which_segment=seg;
				lowestMeta = iteration;
			} 
			
		}
		
		// call the metas
		uint32_t dividendMeta=DividendMeta(data_,size_,which_segment);
		uint32_t divisorMeta=DivisorMeta(data_,size_,which_segment);
		uint32_t segmentSize=SegmentSize(data_,size_,which_segment);
		uint32_t low_index= segmentSize * (which_segment-1);
		
		float coef= dividendMeta / divisorMeta;
		
		// if(debug_){
			// cout << "Restart Index: " << restart_index_ << endl;
			// cout << "segmentSize: "<< segmentSize << "\n";
			// cout << "which_segment: "<< which_segment << "\n";
			// cout << "dividendMeta: "<< dividendMeta << "\n";
			// cout << "divisorMeta: "<< divisorMeta << "\n";
			// cout << "lowestMeta: "<< lowestMeta << "\n";
			// cout << "low_index: "<< low_index << "\n";
			// cout << "$$!------------------" << endl;
			// cout << "coef: " << coef << endl;
			// cout << "find: "<< find << "\n";
			// cout << "lowest_: "<< lowest_ << "\n";
		// }
		
		//prediction formulas
		int atas = find - lowestMeta;
		float prediksi2 = atas/coef + low_index;
		int prediksi = prediksi2;
		
		// if(debug_){
			// cout << "Find: "<< find << "\n";
			// cout << "Dividend: "<< atas << " (Find-helper)\n";
			// cout << "Divisor: "<< coef << "\n";
			
			// cout << "Prediction int: "<< prediksi << "\n";
			// cout << "Prediction: "<< prediksi2 << "\n\n";
		// }
		
		// if prediction is lower then 0
		// we assume it as 0
		if(prediksi < 0){
			prediksi=0;
		}
		
		//First Comparison
		//find restart point first val
		uint32_t region_offset = GetRestartPoint(prediksi);
		uint32_t shared, non_shared, value_length;
		
		const char* key_ptr =
		  DecodeEntry(data_ + region_offset, data_ + restarts_, &shared,
					  &non_shared, &value_length);
		if (key_ptr == nullptr || (shared != 0)) {
			CorruptionError();
			return;
		}
		Slice mid_key(key_ptr, non_shared);
		
		int cmp=Compare(mid_key, target);
		string mkk= mid_key.ToString();
		string tkk= target.ToString();
		
		// if(debug_){
			// cout << "CMP " << cmp << endl;
			// cout << "mkk " << mkk << endl;
			// cout << "tkk " << tkk << endl;
		// }
		// int tot=1;
		
		if (cmp < 0) {
		
			//the left side isn't interesting
			int max = prediksi + 10;
			if(max >= restart_index_){
				max= restart_index_ - 1;
			}
			for(int b= prediksi+1 ; b <= max; b++){
				//checking inside
				uint32_t region_offset_in = GetRestartPoint(b);
				uint32_t shared_in, non_shared_in, value_length_in;
				
				const char* key_ptr_in =
				  DecodeEntry(data_ + region_offset_in, data_ + restarts_, &shared_in,
							  &non_shared_in, &value_length_in);
				if (key_ptr_in == nullptr || (shared_in != 0)) {
					CorruptionError();
					return;
				}
				Slice mid_key_in(key_ptr_in, non_shared_in);
				
				// if(debug_){
					// cout << "CMP " << Compare(mid_key_in,target) << endl;
					// tot++;
					// cout << "b " << b << endl;
					// cout << "mid_key_in " << mid_key_in.ToString() << endl;
				// }
				
				if (Compare(mid_key_in, target) > 0) {
					
					left = b;
					break;
				}
				
				//checking inside
				
		  }
		} else {
			//right side isn't interesting
			int max = prediksi - 10;
			if(max < 0){
				max= 0;
			}
			for(int b= prediksi - 1; b >= max; b--){
				//checking inside
				uint32_t region_offset_in = GetRestartPoint(b);
				uint32_t shared_in, non_shared_in, value_length_in;
				
				const char* key_ptr_in =
				  DecodeEntry(data_ + region_offset_in, data_ + restarts_, &shared_in,
							  &non_shared_in, &value_length_in);
				if (key_ptr_in == nullptr || (shared_in != 0)) {
					CorruptionError();
					return;
				}
				Slice mid_key_in(key_ptr_in, non_shared_in);
				
				int cmp=Compare(mid_key_in, target);
				
				// if(debug_){
					// cout << "CMP " << cmp << endl;
					// tot++;
				// }
				if (Compare(mid_key_in, target) < 0) {
					
					left = b;
					break;
				}
				
				//checking inside
			}
		}
		
		// if(debug_){
			// cout << "------------------!## TOT: " << tot << endl; 
			// cout << find << "," << tot << endl; 
		// }
		
		
	}else{
		 // binary search part
		//original
		if (Valid()) {
		  // If we're already scanning, use the current position as a starting
		  // point. This is beneficial if the key we're seeking to is ahead of the
		  // current position.
		  current_key_compare = Compare(key_, target);
		  if (current_key_compare < 0) {
			// key_ is smaller than target
			left = restart_index_;
		  } else if (current_key_compare > 0) {
			right = restart_index_;
		  } else {
			 // cout << "we are here " << endl;
			// We're seeking to the key we're already at.
			return;
		  }
		}
		// int tot=0;
		while (left < right) {
		  uint32_t mid = (left + right + 1) / 2;
		  uint32_t region_offset = GetRestartPoint(mid);
		  uint32_t shared, non_shared, value_length;
		  // uint32_t wax = data_ + region_offset;
		  // uint32_t wax2 = data_ + restarts_;
		  const char* key_ptr =
			  DecodeEntry(data_ + region_offset, data_ + restarts_, &shared,
						  &non_shared, &value_length);
		  if (key_ptr == nullptr || (shared != 0)) {
			CorruptionError();
			return;
		  }
		  Slice mid_key(key_ptr, non_shared);
		  
		  int cmp=Compare(mid_key, target);
				
		  if (Compare(mid_key, target) < 0) {
		  // if (cmp < 0) {
			// Key at "mid" is smaller than "target".  Therefore all
			// blocks before "mid" are uninteresting.
			left = mid;
		  } else {
			// Key at "mid" is >= "target".  Therefore all blocks at or
			// after "mid" are uninteresting.
			right = mid - 1;
		  }
		  
		  // tot++;
		  // if(debug_){
				// std::string skey= mid_key.ToString();
			  // cout << "<!***************" << endl;
			  // cout << "mid " << mid << endl;
			  // cout << "CMP " << cmp << endl;
			  // // cout << "wax " << wax << endl;
			  // // cout << "wax2 " << wax2 << endl;
			  // cout << "data_ " << data_ << endl;
			  // cout << "restarts_ " << restarts_ << endl;
			  // cout << "region_offset " << region_offset << endl;
			  // cout << "mid_key " << skey << endl;
			  // cout << "key_ptr " << key_ptr << endl;
			  // cout << "togot " << togot << endl;
			  // cout << "left " << left << endl;
			  // cout << "right " << right << endl;
			  // cout << "***************!>" << endl;
			// }
		  
		}
		
		//original
	}

    
    // We might be able to use our current position within the restart block.
    // This is true if we determined the key we desire is in the current block
    // and is after than the current key.
    assert(current_key_compare == 0 || Valid());
    bool skip_seek = left == restart_index_ && current_key_compare < 0;
    if (!skip_seek) {
		
		
      SeekToRestartPoint(left);
    }
	
    // Linear search (within restart block) for first key >= target
	int lp=1;
    while (true) {
		
      if (!ParseNextKey()) {
		
        return;
      }
	  
	  
      if (Compare(key_, target) >= 0) {
        return;
      }
    }
  }

  void SeekToFirst() override {
    SeekToRestartPoint(0);
    ParseNextKey();
  }

  void SeekToLast() override {
    SeekToRestartPoint(num_restarts_ - 1);
    while (ParseNextKey() && NextEntryOffset() < restarts_) {
      // Keep skipping
    }
  }

 private:
  void CorruptionError() {
    current_ = restarts_;
    restart_index_ = num_restarts_;
	// cout << "restart_index_3 :" << restart_index_ << endl;
    status_ = Status::Corruption("bad entry in block");
    key_.clear();
    value_.clear();
  }

  bool ParseNextKey() {
    current_ = NextEntryOffset();
    const char* p = data_ + current_;
    const char* limit = data_ + restarts_;  // Restarts come right after data
    if (p >= limit) {
      // No more entries to return.  Mark as invalid.
      current_ = restarts_;
      restart_index_ = num_restarts_;
	  // cout << "restart_index_4 :" << restart_index_ << endl;
      return false;
    }

    // Decode next entry
    uint32_t shared, non_shared, value_length;
    p = DecodeEntry(p, limit, &shared, &non_shared, &value_length);
    if (p == nullptr || key_.size() < shared) {
      CorruptionError();
      return false;
    } else {
      key_.resize(shared);
      key_.append(p, non_shared);
      value_ = Slice(p + non_shared, value_length);
      while (restart_index_ + 1 < num_restarts_ &&
             GetRestartPoint(restart_index_ + 1) < current_) {
        ++restart_index_;
		
		// cout << "restart_index_5 :" << restart_index_ << endl;
      }
      return true;
    }
  }
};

// vector<int> LowestLists()
// {
    // vector<int> mult;
    // mult.reserve(5);
	// mult.push_back(Lowest(1));
	// mult.push_back(Lowest(2));
	// mult.push_back(Lowest(3));
	// mult.push_back(Lowest(4));
	// mult.push_back(Lowest(5));
    // return mult;
// }

Iterator* Block::NewIterator(const Comparator* comparator) {
  if (size_ < sizeof(uint32_t)) {
    return NewErrorIterator(Status::Corruption("bad block contents"));
  }
  const uint32_t num_restarts = NumRestarts();
  
   // //init LR dividend
  // const uint32_t dividend = Dividend(1);
  // const uint32_t divisor = Divisor(1);
  // //init LR lowest subset
  // const float lowest = Lowest(1);
  // // vector<int> lowestLists = LowestLists();
  
  // cout << "NumRestarts(): " << num_restarts << endl;
  // cout << "Dividend(): " << dividend << endl;
  // cout << "Divisor(): " << divisor << endl; 
  // cout << "Lowest(): " << lowest << endl;
  
  // vector<int> LowestLists;
    // LowestLists.reserve(5);
	// LowestLists.push_back(Lowest(1));
	// LowestLists.push_back(Lowest(2));
	// LowestLists.push_back(Lowest(3));
	// LowestLists.push_back(Lowest(4));
	// LowestLists.push_back(Lowest(5));
    
	// cout << "SLR" << SLR << endl;
  
  // printf( "%6.4lf \n", lowest );
  
  // printf("dividend %02hhx \n", dividend);
  if (num_restarts == 0) {
    return NewEmptyIterator();
  } else {
    // return new Iter(comparator, data_, restart_offset_, num_restarts);
    
	//add some variable into the iteration
    return new Iter(comparator, data_, restart_offset_, num_restarts,size_, SLR, debug);
   
  }
}

}  // namespace leveldb
